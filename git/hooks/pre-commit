#!/bin/sh
# Pre-commit hook for basic code quality checks

if [ -t 2 ]; then
    RED=$(printf '\033[0;31m')
    GREEN=$(printf '\033[0;32m')
    YELLOW=$(printf '\033[1;33m')
    NC=$(printf '\033[0m')
else
    RED=''
    GREEN=''
    YELLOW=''
    NC=''
fi

staged_files=$(mktemp) || exit 1
trap 'rm -f "$staged_files"' EXIT HUP INT TERM

git diff --cached --name-only --diff-filter=ACMR >"$staged_files"

error() {
    printf '%s\n' "${RED}Error: $*${NC}" >&2
}

warning() {
    printf '%s\n' "${YELLOW}Warning: $*${NC}" >&2
}

info() {
    printf '%s\n' "$*"
}

file_size_bytes() {
    file=$1
    if size=$(stat -c%s "$file" 2>/dev/null); then
        printf '%s' "$size"
        return 0
    fi
    if size=$(stat -f%z "$file" 2>/dev/null); then
        printf '%s' "$size"
        return 0
    fi
    wc -c <"$file" | tr -d ' '
}

check_debug_prints() {
    found=0

    # Python: disallow added print(...) unless explicitly allowed.
    while IFS= read -r file; do
        case $file in
        bin/*) ;;
        *.py)
            matches=$(git diff --cached -- "$file" |
                grep -E '^\+[^+].*print\(' |
                grep -v '# noqa: print' || true)
            if [ -n "$matches" ]; then
                if [ $found -eq 0 ]; then
                    error "Found print statements in Python files"
                    printf '%s\n' "Remove debug prints or add '# noqa: print' comment to allow" >&2
                fi
                printf '%s\n' "  $file:" >&2
                printf '%s\n' "$matches" | sed 's/^/    /' >&2
                found=1
            fi
            ;;
        esac
    done <"$staged_files"

    # JS/TS: disallow added console.(log|debug|info) unless explicitly allowed.
    while IFS= read -r file; do
        case $file in
        *.js | *.jsx | *.ts | *.tsx)
            matches=$(git diff --cached -- "$file" |
                grep -E '^\+[^+].*console\.(log|debug|info)' |
                grep -v '// eslint-disable-line' || true)
            if [ -n "$matches" ]; then
                if [ $found -eq 0 ]; then
                    error "Found console statements in JS/TS files"
                    printf '%s\n' "Remove debug logs or add '// eslint-disable-line' comment to allow" >&2
                fi
                printf '%s\n' "  $file:" >&2
                printf '%s\n' "$matches" | sed 's/^/    /' >&2
                found=1
            fi
            ;;
        esac
    done <"$staged_files"

    [ $found -eq 0 ]
}

check_large_files() {
    max_size=$((5 * 1024 * 1024)) # 5MB
    large_files=''

    while IFS= read -r file; do
        [ -f "$file" ] || continue
        size=$(file_size_bytes "$file" 2>/dev/null || printf '0')
        if [ "$size" -gt "$max_size" ]; then
            mb=$(( (size + 1048575) / 1048576 ))
            if [ -z "$large_files" ]; then
                large_files="  $file (${mb}MB)"
            else
                large_files="$large_files
  $file (${mb}MB)"
            fi
        fi
    done <"$staged_files"

    if [ -n "$large_files" ]; then
        warning "Large files detected:"
        printf '%s\n' "$large_files" >&2
        printf '%s\n' "Consider using Git LFS for large files" >&2
    fi
}

check_merge_conflicts() {
    if git diff --cached | grep -qE '^[+-](<<<<<<<|=======|>>>>>>>)'; then
        error "Merge conflict markers detected"
        return 1
    fi
    return 0
}

check_trailing_whitespace() {
    ws=$(git diff --cached --check || true)
    if [ -n "$ws" ]; then
        error "Trailing whitespace detected"
        printf '%s\n' "$ws" >&2
        return 1
    fi
    return 0
}

check_scheme_style() {
    command -v guix >/dev/null 2>&1 || return 0

    needs_check=0
    while IFS= read -r file; do
        case $file in
        *.scm) needs_check=1 ;;
        esac
    done <"$staged_files"

    [ $needs_check -eq 1 ] || return 0

    info "${YELLOW}Checking Scheme file style...${NC}"

    while IFS= read -r file; do
        case $file in
        *.scm)
            tmp_original=$(mktemp) || return 1
            tmp_styled=$(mktemp) || {
                rm -f "$tmp_original"
                return 1
            }

            if ! git show ":$file" >"$tmp_original" 2>/dev/null; then
                rm -f "$tmp_original" "$tmp_styled"
                continue
            fi

            cp "$tmp_original" "$tmp_styled"
            guix style -f "$tmp_styled" >/dev/null 2>&1 || true

            if ! diff -q "$tmp_original" "$tmp_styled" >/dev/null; then
                error "$file needs formatting"
                printf '%s\n' "Run: guix style -f $file" >&2
                rm -f "$tmp_original" "$tmp_styled"
                return 1
            fi

            rm -f "$tmp_original" "$tmp_styled"
            ;;
        esac
    done <"$staged_files"

    return 0
}

check_emacs_doctor() {
    [ "${SKIP_EMACS_DOCTOR:-}" = "1" ] && return 0

    needs_check=0
    while IFS= read -r file; do
        case $file in
        emacs/* | docs/emacs/*) needs_check=1 ;;
        esac
    done <"$staged_files"

    [ $needs_check -eq 1 ] || return 0

    command -v emacs >/dev/null 2>&1 || {
        warning "Emacs not found; skipping Emacs config doctor"
        return 0
    }

    info "${YELLOW}Running Emacs config doctor...${NC}"
    if ! scripts/emacs-doctor.sh; then
        error "Emacs config doctor failed"
        printf '%s\n' "Run: scripts/emacs-doctor.sh" >&2
        return 1
    fi
    return 0
}

failed=0
info "Running pre-commit checks..."

check_debug_prints || failed=1
check_large_files
check_merge_conflicts || failed=1
check_trailing_whitespace || failed=1
check_scheme_style || failed=1
check_emacs_doctor || failed=1

if [ $failed -ne 0 ]; then
    printf '%s\n' "${RED}Pre-commit checks failed!${NC}" >&2
    exit 1
fi

printf '%s\n' "${GREEN}All pre-commit checks passed!${NC}"
exit 0
